{
  "language": "Solidity",
  "sources": {
    "contracts/amm/uniswap-v1/Exchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * THIS IS AN EXAMPLE CONTRACT WHICH IS NOT AUDITED\n * PLEASE DO NOT USE THIS CODE IN PRODUCTION.\n */\n\ninterface IExchange {\n    function ethToTokenSwap(uint256 expectedTokenAmount) external payable;\n\n    function ethToTokenTransfer(uint256 expectedTokenAmount, address recipient) external payable;\n}\n\ninterface IFactory {\n    function getExchange(address tokenAddress) external returns (address);\n}\n\ncontract Exchange is ERC20 {\n    address public tokenAddress;\n    address public factoryAddress;\n\n    // events\n    event TokenPurchase(address indexed buyer, uint256 indexed ethSold, uint256 tokenBought);\n    event EthPurchase(address indexed buyer, uint256 indexed tokenSold, uint256 ethBought);\n    event AddLiquidity(\n        address indexed provider,\n        uint256 indexed ethAmount,\n        uint256 indexed tokenAmount\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256 indexed ethAmount,\n        uint256 indexed tokenAmount\n    );\n\n    constructor(address token) ERC20(\"Funkyswap V1\", \"FUNKY-V1\") {\n        require(token != address(0), \"invalid token address\");\n        tokenAddress = token;\n        factoryAddress = msg.sender;\n    }\n\n    /**\n     * Called by liquidity providers. Must provide the same value of `tokenAmount` as `msg.value` in order to respect the current reserve ratio\n     * reserve formula to respect: (tokenAmount/msg.value) = (tokenReserve/ethReserve)\n     * @param tokenAmount uint256: input amount of token that liquidity provider is depositing\n     * @return poolTokenAmount uint256: amount of pool token rewarded to the liquidity provider\n     * @notice payable modifier: expect to receive `msg.value` ETH\n     * @notice at initialization (when `tokenReserve` ==0) , allow the 1st liquidity provider to decide on the initial reserve ratio\n     * @notice check that the liquidity provider has provided enough `tokenAmount` and take only what's needed (`expectedTokenAmount`)\n     * @notice reward liquidity provider with pool tokens. Amount of tokens is proportional to the amout of eth provider comparatively to the total ETH reserve.\n     */\n    function addLiquidity(uint256 tokenAmount) public payable returns (uint256 poolTokenAmount) {\n        // Retrieve reserves\n        (uint256 tokenReserve, uint256 ethReserve) = getReserves();\n        if (tokenReserve == 0) {\n            // at initialization of the exchange, we accept whatever the 1st liquidity provider has given us\n            IERC20 token = IERC20(tokenAddress);\n            token.transferFrom(msg.sender, address(this), tokenAmount);\n            // at initialization , pook token amount is equal to the amount of ethers\n            poolTokenAmount = ethReserve;\n        } else {\n            // Substract msg.value from the balance before calling the getAmount function\n            ethReserve = ethReserve - msg.value;\n            // expected amount based on the current reserve ratio tokenReserve / ethReserve\n            uint256 expectedtokenAmount = (msg.value * tokenReserve) / ethReserve;\n            require(tokenAmount >= expectedtokenAmount, \"Insufficient token amount\");\n            IERC20 token = IERC20(tokenAddress);\n            token.transferFrom(msg.sender, address(this), expectedtokenAmount);\n            // pool token amount based on ratio providedEth/ethReserve\n            // (poolTokenAmount/totalPoolTokenSupply) = (depositedEth/ethReserve)\n            poolTokenAmount = (totalSupply() * msg.value) / ethReserve;\n        }\n        // reward the liquidity provider with calculated pool tokens amount\n        _mint(msg.sender, poolTokenAmount);\n        emit AddLiquidity(msg.sender, msg.value, tokenAmount);\n    }\n\n    /**\n     * Called by liquidity providers. Burn pool tokens in exchange of ETH & Tokens at current ratios.\n     *\n     * @param poolTokenAmount uint256: Amount of pool token to be burned\n     * @return ethAmount uint256: Amount of ETH withdrawn\n     * @return tokenAmount uint256: Amount of Tokens withdrawn\n     */\n    function removeLiquidity(uint256 poolTokenAmount)\n        public\n        returns (uint256 ethAmount, uint256 tokenAmount)\n    {\n        require(poolTokenAmount > 0, \"Amount of pool token cannot be 0\");\n        // Retrieve reserves\n        (uint256 tokenReserve, uint256 ethReserve) = getReserves();\n\n        // calculate the amount of Token & ETH based on the ratio\n        ethAmount = (ethReserve * poolTokenAmount) / totalSupply();\n        tokenAmount = (tokenReserve * poolTokenAmount) / totalSupply();\n\n        // reduce supply of pool tokens\n        _burn(msg.sender, poolTokenAmount);\n        // returns ETH & Token to the liquidity provider\n        (bool sent, ) = (msg.sender).call{value: ethAmount}(\"\");\n        require(sent, \"Failed to send Ether\");\n        IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n        emit RemoveLiquidity(msg.sender, ethAmount, tokenAmount);\n    }\n\n    /**\n     * @dev Pricing function `outputAmount` of token2 if we provide `inputAmount` of token1 in exchange.\n     *\n     * @param inputAmount uint256: Amount of token1 we are selling\n     * @param inputReserve uint256: Reserve of token1 we are selling\n     * @param outputReserve uint256: Reserve of token2 we are buying\n     * @return outputAmount uint256: Amount of token2 we receive in exchange\n     *\n     * @notice fees taken intout account. 0,3 % fees . 0,3 % = 3/1000. Fees removed from `inputAmount`\n     */\n    function getAmount(\n        uint256 inputAmount,\n        uint256 inputReserve,\n        uint256 outputReserve\n    ) private pure returns (uint256 outputAmount) {\n        require(inputReserve > 0 && outputReserve > 0, \"Reserves cannot be null\");\n        uint256 inputAmountWithFee = inputAmount * 997;\n        uint256 numerator = inputAmountWithFee * outputReserve;\n        uint256 denominator = (1000 * inputReserve + inputAmountWithFee);\n\n        outputAmount = numerator / denominator;\n    }\n\n    /**\n     * Get `tokenAmount` if we provide `ethAmount` in exchange.\n     *\n     * @param ethAmount uint256: Amount of ETH we are selling\n     * @return tokenAmount uint256: Amount of Token we receive in exchange\n     */\n    function getTokenAmount(uint256 ethAmount) public view returns (uint256 tokenAmount) {\n        require(ethAmount > 0, \"Eth amount cannot be null\");\n\n        // Retrieve reserves\n        // Retrieve reserves\n        (uint256 tokenReserve, uint256 ethReserve) = getReserves();\n\n        // Trading ethAmount for tokenAmount (= Buy Token with Eth)\n        tokenAmount = getAmount(ethAmount, ethReserve, tokenReserve);\n    }\n\n    /**\n     * Get `ethAmount` if we provide `tokenAmount` in exchange.\n     *\n     * @param tokenAmount uint256: Amount of Token we are selling\n     * @return ethAmount uint256: Amount of ETH we receive in exchange\n     */\n    function getEthAmount(uint256 tokenAmount) public view returns (uint256 ethAmount) {\n        require(tokenAmount > 0, \"Token amount cannot be null\");\n\n        // Retrieve reserves\n        (uint256 tokenReserve, uint256 ethReserve) = getReserves();\n\n        // Trading tokenAmount for ethAmount (= Sell Token for Eth)\n        ethAmount = getAmount(tokenAmount, tokenReserve, ethReserve);\n    }\n\n    /**\n     * Buy `expectedTokenAmount` in exchange of at least `msg.value` ETH\n     *\n     * @notice Protect users from front-running bots but asking them to provide `expectedTokenAmount`\n     *\n     * @param expectedTokenAmount uint256: Expected amount of token to be received by the user\n     * @param recipient address: Recipient address\n     */\n    function ethToToken(uint256 expectedTokenAmount, address recipient) private {\n        // Retrieve reserves\n        (uint256 tokenReserve, uint256 ethReserve) = getReserves();\n\n        uint256 tokenAmount = getAmount(msg.value, ethReserve - msg.value, tokenReserve);\n\n        require(tokenAmount >= expectedTokenAmount, \"Token Amount low\");\n\n        IERC20(tokenAddress).transfer(recipient, tokenAmount);\n        emit TokenPurchase(recipient, msg.value, tokenAmount);\n    }\n\n    /**\n     * Buy `expectedTokenAmount` in exchange of at least `msg.value` ETH\n     *\n     * @notice Because the function receives ETH , `msg.value` has been added to the ETH reserve. Hence, we need to subsctract it before calling the `getAmount` function\n     * @notice Protect users from front-running bots but asking them to provide `expectedTokenAmount`\n     *\n     * @param expectedTokenAmount uint256: Expected amount of token to be received by the user\n     * @param recipient address: Recipient address\n     */\n    function ethToTokenTransfer(uint256 expectedTokenAmount, address recipient) public payable {\n        ethToToken(expectedTokenAmount, recipient);\n    }\n\n    /**\n     * Buy `expectedTokenAmount` in exchange of at least `msg.value` ETH\n     *\n     * @notice Because the function receives ETH , `msg.value` has been added to the ETH reserve. Hence, we need to subsctract it before calling the `getAmount` function\n     * @notice Protect users from front-running bots but asking them to provide `expectedTokenAmount`\n     *\n     * @param expectedTokenAmount uint256: Expected amount of token to be received by the user\n     * @dev Calls `ethToToken()` . recipient is `msg.sender`\n     */\n    function ethToTokenSwap(uint256 expectedTokenAmount) public payable {\n        ethToToken(expectedTokenAmount, msg.sender);\n    }\n\n    /**\n     * Sell `tokenAmount` in exchange of at least `expectedEthAmount` ETH\n     *\n     * @notice Protect users from front-running bots but asking them to provide `expectedTokenAmount`\n     *\n     * @param tokenAmount uint256: Amount of Token sold to the Exchange\n     * @param expectedEthAmount uint256: Expected amount of ETH to be received by the user\n     */\n    function tokenToEthSwap(uint256 tokenAmount, uint256 expectedEthAmount) public {\n        // Retrieve reserves\n        (uint256 tokenReserve, uint256 ethReserve) = getReserves();\n\n        uint256 ethAmount = getAmount(tokenAmount, tokenReserve, ethReserve);\n\n        require(ethAmount >= expectedEthAmount, \"Eth Amount low\");\n\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), tokenAmount);\n        (bool sent, ) = (msg.sender).call{value: ethAmount}(\"\");\n        require(sent, \"Failed to send Ether\");\n        emit EthPurchase(msg.sender, tokenAmount, ethAmount);\n    }\n\n    /**\n     * Sell `tokenAmount` in exchange for at least `expectedTargetTokenAmount` of target Token\n     *\n     * @dev ETH uses as a bridge. Token --> ETH --> Target Token\n     *\n     * @param tokenAmount uint256: Amount of Token sold to the Exchange\n     * @param expectedTargetTokenAmount uint256: Expected amount of Target token to be received by the user\n     * @param targetTokenAddress address: Target Token address\n     */\n    function tokenToTokenSwap(\n        uint256 tokenAmount,\n        uint256 expectedTargetTokenAmount,\n        address targetTokenAddress\n    ) public {\n        require(targetTokenAddress != address(0), \"Token address not valid\");\n        require(tokenAmount > 0, \"Tokens amount not valid\");\n        address targetExchangeAddress = IFactory(factoryAddress).getExchange(targetTokenAddress);\n        require(\n            targetExchangeAddress != address(this) && targetExchangeAddress != address(0),\n            \"Exchange address not valid\"\n        );\n\n        // Retrieve reserves\n        (uint256 tokenReserve, uint256 ethReserve) = getReserves();\n        uint256 ethAmount = getAmount(tokenAmount, tokenReserve, ethReserve);\n\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), tokenAmount);\n\n        IExchange(targetExchangeAddress).ethToTokenTransfer{value: ethAmount}(\n            expectedTargetTokenAmount,\n            msg.sender\n        );\n    }\n\n    /**\n     * Return reserves of Token & ETH within the exchange\n     * @return tokenReserve uint256 : Exchange Token Balance\n     * @return ethReserve uint256: Exchange ETH Balance\n     */\n    function getReserves() public view returns (uint256 tokenReserve, uint256 ethReserve) {\n        // Retrieve reserves\n        tokenReserve = IERC20(tokenAddress).balanceOf(address(this));\n        ethReserve = address(this).balance;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/amm/uniswap-v1/Factory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./Exchange.sol\";\n\n/**\n * THIS IS AN EXAMPLE CONTRACT WHICH IS NOT AUDITED\n * PLEASE DO NOT USE THIS CODE IN PRODUCTION.\n */\ncontract Factory {\n    mapping(address => address) public exchanges;\n\n    /**\n     * Create and deploy a new exchange\n     *\n     * @param tokenAddress address: Token address for which the factory will create an exchange\n     * @return exchangeAddress address: Token/ETH Exchange address\n     * @notice a similar exchange must not exist\n     */\n    function createExchange(address tokenAddress) public returns (address exchangeAddress) {\n        require(tokenAddress != address(0), \"Token address not valid\");\n        require(exchanges[tokenAddress] == address(0), \"Exchange already exists\");\n\n        Exchange exchange = new Exchange(tokenAddress);\n        exchanges[tokenAddress] = address(exchange);\n\n        exchangeAddress = address(exchange);\n    }\n\n    /**\n     * Find an exchange\n     *\n     * @param tokenAddress address: Token address for which the factory will create an exchange\n     * @return exchangeAddress address: Token/ETH Exchange address\n     */\n    function getExchange(address tokenAddress) public view returns (address exchangeAddress) {\n        exchangeAddress = exchanges[tokenAddress];\n        require(exchangeAddress != address(0), \"Exchange does exists\");\n    }\n}\n"
    },
    "contracts/stablecoins/exogenousAnchoredCoin/DSCEngine.sol": {
      "content": "// Based VEEEEEEEEEEERY LOOSELY on the MakerDAO DSS System (Dsc)\n// Also has some Aave mixed in\n\n/////////////////////////////////////////////////\n/******  We are ignoring the following modules: *********/\n// System Stabilizer: We are pretending that our liquidation model is good enough\n// (It's definetly not)\n// https://docs.makerdao.com/smart-contract-modules/system-stabilizer-module\n\n// Oracle Module:\n// We use Chainlink instead\n// https://docs.makerdao.com/smart-contract-modules/oracle-module\n\n// MKR Module:\n// The MKR Module is for governance and a backstop against becoming insolvent.\n// This is crucial for production\n// https://docs.makerdao.com/smart-contract-modules/mkr-module\n\n// Governance Module:\n// See above\n// https://docs.makerdao.com/smart-contract-modules/governance-module\n\n// Rates Module:\n// We are removing the rates module because we don't have governance\n// We could include it more protection against insolvency, but we are going to pretend (again) that our liquidation thresholds are high enough\n// https://docs.makerdao.com/smart-contract-modules/rates-module\n\n// Flash Mint Module\n// Not necesary\n// https://docs.makerdao.com/smart-contract-modules/flash-mint-module\n\n// Emergency Shutdown Module:\n// Because\n// https://docs.makerdao.com/smart-contract-modules/shutdown\n/////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n/******  Included Modules: *********/\n\n// Core Module\n// Collateral Module (but wrapped into one contract)\n// Liquidation Module (but wrapped into one contract)\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./DecentralizedStableCoin.sol\";\nimport \"hardhat/console.sol\";\n\nerror DSCEngine__TokenAddressesAndPriceFeedAddressesAmountsDontMatch();\nerror DSCEngine__NeedsMoreThanZero();\nerror DSCEngine__TokenNotAllowed(address token);\nerror DSCEngine__TransferFailed();\nerror DSCEngine__BreaksHealthFactor();\nerror DSCEngine__MintFailed();\nerror DSCEngine__MustBreaksHealthFactor();\nerror DSCEngine__HealthFactorOk();\n\ncontract DSCEngine is ReentrancyGuard {\n    uint256 public constant LIQUIDATION_THRESHOLD = 50; // This means you need to be 200% over-collateralized\n    uint256 public constant LIQUIDATION_BONUS = 10; // This means you get assets at a 10% discount when liquidating\n    uint256 public constant MIN_HEALTH_FACTOR = 1e18;\n    DecentralizedStableCoin public immutable i_dsc;\n\n    mapping(address => address) public s_tokenAddressToPriceFeed;\n    // user -> token -> amount\n    mapping(address => mapping(address => uint256)) public s_userToTokenAddressToAmountDeposited;\n    // user -> amount\n    mapping(address => uint256) public s_userToDscMinted;\n    address[] public s_collateralTokens;\n\n    event CollateralDeposited(address indexed user, uint256 indexed amount);\n\n    modifier moreThanZero(uint256 amount) {\n        if (amount == 0) {\n            revert DSCEngine__NeedsMoreThanZero();\n        }\n        _;\n    }\n\n    modifier isAllowedToken(address token) {\n        if (s_tokenAddressToPriceFeed[token] == address(0)) {\n            revert DSCEngine__TokenNotAllowed(token);\n        }\n        _;\n    }\n\n    constructor(\n        address[] memory tokenAddresses,\n        address[] memory priceFeedAddresses,\n        address dscAddress\n    ) {\n        if (tokenAddresses.length != priceFeedAddresses.length) {\n            revert DSCEngine__TokenAddressesAndPriceFeedAddressesAmountsDontMatch();\n        }\n        // These feeds will be the USD pairs\n        // For example ETH / USD or MKR / USD\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            s_tokenAddressToPriceFeed[tokenAddresses[i]] = priceFeedAddresses[i];\n            s_collateralTokens.push(tokenAddresses[i]);\n        }\n        // i_dsc = new DecentralizedStableCoin();\n        i_dsc = DecentralizedStableCoin(dscAddress);\n    }\n\n    function depositCollateralAndMintDsc(\n        address tokenCollateralAddress,\n        uint256 amountCollateral,\n        uint256 amountDscToMint\n    ) external {\n        despositCollateral(tokenCollateralAddress, amountCollateral);\n        mintDsc(amountDscToMint);\n    }\n\n    function despositCollateral(address tokenCollateralAddress, uint256 amountCollateral)\n        public\n        moreThanZero(amountCollateral)\n        nonReentrant\n        isAllowedToken(tokenCollateralAddress)\n    {\n        s_userToTokenAddressToAmountDeposited[msg.sender][\n            tokenCollateralAddress\n        ] += amountCollateral;\n        emit CollateralDeposited(msg.sender, amountCollateral);\n        bool success = IERC20(tokenCollateralAddress).transferFrom(\n            msg.sender,\n            address(this),\n            amountCollateral\n        );\n        if (!success) {\n            revert DSCEngine__TransferFailed();\n        }\n    }\n\n    function redeemCollateralForDsc(\n        address tokenCollateralAddress,\n        uint256 amountCollateral,\n        uint256 amountDscToBurn\n    ) external {\n        burnDsc(amountDscToBurn);\n        redeemCollateral(tokenCollateralAddress, amountCollateral);\n    }\n\n    function redeemCollateral(address tokenCollateralAddress, uint256 amountCollateral)\n        public\n        moreThanZero(amountCollateral)\n        nonReentrant\n    {\n        _redeemCollateral(tokenCollateralAddress, amountCollateral, msg.sender, msg.sender);\n        revertIfHealthFactorIsBroken(msg.sender);\n    }\n\n    function _redeemCollateral(\n        address tokenCollateralAddress,\n        uint256 amountCollateral,\n        address from,\n        address to\n    ) private {\n        s_userToTokenAddressToAmountDeposited[from][tokenCollateralAddress] -= amountCollateral;\n        bool success = IERC20(tokenCollateralAddress).transfer(to, amountCollateral);\n        if (!success) {\n            revert DSCEngine__TransferFailed();\n        }\n    }\n\n    // Don't call this function directly, you will just lose money!\n    function burnDsc(uint256 amountDscToBurn) public moreThanZero(amountDscToBurn) nonReentrant {\n        _burnDsc(amountDscToBurn, msg.sender, msg.sender);\n        revertIfHealthFactorIsBroken(msg.sender);\n    }\n\n    function _burnDsc(\n        uint256 amountDscToBurn,\n        address onBehalfOf,\n        address dscFrom\n    ) private {\n        s_userToDscMinted[onBehalfOf] -= amountDscToBurn;\n        bool success = i_dsc.transferFrom(dscFrom, address(this), amountDscToBurn);\n        if (!success) {\n            revert DSCEngine__TransferFailed();\n        }\n        i_dsc.burn(amountDscToBurn);\n    }\n\n    function mintDsc(uint256 amountDscToMint) public moreThanZero(amountDscToMint) nonReentrant {\n        s_userToDscMinted[msg.sender] += amountDscToMint;\n        revertIfHealthFactorIsBroken(msg.sender);\n        bool minted = i_dsc.mint(msg.sender, amountDscToMint);\n        if (minted != true) {\n            revert DSCEngine__MintFailed();\n        }\n    }\n\n    function getAccountInformation(address user)\n        public\n        view\n        returns (uint256 totalDscMinted, uint256 collateralValueInUsd)\n    {\n        totalDscMinted = s_userToDscMinted[user];\n        collateralValueInUsd = getAccountCollateralValue(user);\n    }\n\n    function healthFactor(address user) public view returns (uint256) {\n        (uint256 totalDscMinted, uint256 collateralValueInUsd) = getAccountInformation(user);\n        if (totalDscMinted == 0) return 100e18;\n        uint256 collateralAdjustedForThreshold = (collateralValueInUsd * LIQUIDATION_THRESHOLD) /\n            100;\n        return (collateralAdjustedForThreshold * 1e18) / totalDscMinted;\n    }\n\n    function getAccountCollateralValue(address user)\n        public\n        view\n        returns (uint256 totalCollateralValueInUsd)\n    {\n        for (uint256 index = 0; index < s_collateralTokens.length; index++) {\n            address token = s_collateralTokens[index];\n            uint256 amount = s_userToTokenAddressToAmountDeposited[user][token];\n            totalCollateralValueInUsd += getUsdValue(token, amount);\n        }\n        return totalCollateralValueInUsd;\n    }\n\n    function getUsdValue(address token, uint256 amount) public view returns (uint256) {\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(s_tokenAddressToPriceFeed[token]);\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        // 1 ETH = 1000 USD\n        // The returned value from Chainlink will be 1000 * 1e8\n        // Most USD pairs have 8 decimals, so we will just pretend they all do\n        // We want to have everything in terms of WEI, so we add 10 zeros at the end\n        return ((uint256(price) * 1e10) * amount) / 1e18;\n\n        // 10.000000000000000000 ETH should be:\n        // 1,000.000000000000000000 USD\n    }\n\n    function getTokenAmountFromUsd(address token, uint256 usdAmountInWei)\n        public\n        view\n        returns (uint256)\n    {\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(s_tokenAddressToPriceFeed[token]);\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        // 1 ETH = 1000 USD\n        // The returned value from Chainlink will be 1000 * 1e8\n        // Most USD pairs have 8 decimals, so we will just pretend they all do\n        return (uint256(price) * 1e10 * 1e18) / usdAmountInWei;\n    }\n\n    function revertIfHealthFactorIsBroken(address user) internal view {\n        uint256 userHealthFactor = healthFactor(user);\n        if (userHealthFactor < MIN_HEALTH_FACTOR) {\n            revert DSCEngine__BreaksHealthFactor();\n        }\n    }\n\n    function liquidate(\n        address collateral,\n        address user,\n        uint256 debtToCover\n    ) external {\n        uint256 startingUserHealthFactor = healthFactor(user);\n        if (startingUserHealthFactor >= MIN_HEALTH_FACTOR) {\n            revert DSCEngine__HealthFactorOk();\n        }\n        uint256 tokenAmountFromDebtCovered = getTokenAmountFromUsd(collateral, debtToCover);\n        uint256 bonusCollateral = (tokenAmountFromDebtCovered * LIQUIDATION_BONUS) / 100;\n        // Burn DSC equal to debtToCover\n        // Figure out how much collateral to recover based on how much burnt\n        _redeemCollateral(\n            collateral,\n            tokenAmountFromDebtCovered + bonusCollateral,\n            user,\n            msg.sender\n        );\n        _burnDsc(debtToCover, user, msg.sender);\n\n        uint256 endingUserHealthFactor = healthFactor(user);\n        require(startingUserHealthFactor < endingUserHealthFactor);\n    }\n}\n\n// Found this out by going through tenderly simulator for:\n// https://dashboard.tenderly.co/tx/mainnet/0x89decb4ff427f63257f4679b3165f4a4f3701b79e9d29d383bd2565b5616bfb7/debugger?trace=0.0.0\n\n// Calls openLockGemAndDraw(): which combines open, lockGem and draw on the DssProxyActions Contract\n// open opens a new cdp (collateralized debt position)\n// lockGem deposits collateral (moves LINK tokens) into this GemJoin contract: https://etherscan.io/address/0xdfccaf8fdbd2f4805c174f856a317765b49e4a50#readContract\n// draw updates collateral fee rate and calls exit which gives Dsc to user\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/stablecoins/exogenousAnchoredCoin/DecentralizedStableCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// This is veeeeeeery loosely based off https://github.com/makerdao/dss (DAI)\n\n// This is considered an Exogenous, Decentralized, Anchored (pegged), Crypto Collateralized low volitility coin\n\n// Collateral: Exogenous\n// Minting: Decentralized\n// Value: Anchored (Pegged to USD)\n// Collateral Type: Crypto\n\n// ExoDRCCoin... Which I'm going to call ExoDaCCoin... ExoDac?\n\n// Sometimes refered to just as \"Crypto Collateralized Stablecoin\" or \"Decentralized Stablecoin\"\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nerror DecentralizedStableCoin__AmountMustBeMoreThanZero();\nerror DecentralizedStableCoin__BurnAmountExceedsBalance();\nerror DecentralizedStableCoin__NotZeroAddress();\n\ncontract DecentralizedStableCoin is ERC20Burnable, Ownable {\n    constructor() ERC20(\"DecentralizedStableCoin\", \"DSC\") {}\n\n    function burn(uint256 _amount) public override onlyOwner {\n        uint256 balance = balanceOf(msg.sender);\n        if (_amount <= 0) {\n            revert DecentralizedStableCoin__AmountMustBeMoreThanZero();\n        }\n        if (balance < _amount) {\n            revert DecentralizedStableCoin__BurnAmountExceedsBalance();\n        }\n        super.burn(_amount);\n    }\n\n    function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {\n        if (_to == address(0)) {\n            revert DecentralizedStableCoin__NotZeroAddress();\n        }\n        if (_amount <= 0) {\n            revert DecentralizedStableCoin__AmountMustBeMoreThanZero();\n        }\n        _mint(_to, _amount);\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/stablecoins/exogenousIndexCoin/IndexCoin.sol": {
      "content": "// This would be similar to a RAI\n// https://reflexer.finance/\n\n// SPDX-License-Identifier: MIT\n\n// This is considered an Exogenous, Decentralized, Indexed, Crypto Collateralized low volitility coin\n\n// Collateral: Exogenous\n// Minting: Decentralized\n// Value: Index (Consumer Index Based Currency)\n// Collateral Type: Crypto\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nerror DecentralizedStableCoin__AmountMustBeMoreThanZero();\nerror DecentralizedStableCoin__BurnAmountExceedsBalance();\nerror DecentralizedStableCoin__NotZeroAddress();\n\ncontract IndexCoin is ERC20Burnable, Ownable {\n    constructor() ERC20(\"IndexCoin\", \"IC\") {}\n\n    function burn(uint256 _amount) public override onlyOwner {\n        uint256 balance = balanceOf(msg.sender);\n        if (_amount <= 0) {\n            revert DecentralizedStableCoin__AmountMustBeMoreThanZero();\n        }\n        if (balance < _amount) {\n            revert DecentralizedStableCoin__BurnAmountExceedsBalance();\n        }\n        super.burn(_amount);\n    }\n\n    function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {\n        if (_to == address(0)) {\n            revert DecentralizedStableCoin__NotZeroAddress();\n        }\n        if (_amount <= 0) {\n            revert DecentralizedStableCoin__AmountMustBeMoreThanZero();\n        }\n        _mint(_to, _amount);\n        return true;\n    }\n}\n"
    },
    "contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _mint(msg.sender, 1000000 * 10**18);\n    }\n}\n"
    },
    "contracts/RewardToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract RewardToken is ERC20 {\n    constructor() ERC20(\"Reward Token\", \"RT\") {\n        _mint(msg.sender, 1000000 * 10**18);\n    }\n}\n"
    },
    "contracts/amm/uniswap-v1/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * THIS IS AN EXAMPLE CONTRACT WHICH IS NOT AUDITED\n * PLEASE DO NOT USE THIS CODE IN PRODUCTION.\n */\ncontract Token is ERC20 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) {\n        _mint(msg.sender, initialSupply);\n    }\n}\n"
    },
    "contracts/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Inspired by https://solidity-by-example.org/defi/staking-rewards/\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nerror TransferFailed();\nerror NeedsMoreThanZero();\n\ncontract Staking is ReentrancyGuard {\n    IERC20 public s_rewardsToken;\n    IERC20 public s_stakingToken;\n\n    // This is the reward token per second\n    // Which will be multiplied by the tokens the user staked divided by the total\n    // This ensures a steady reward rate of the platform\n    // So the more users stake, the less for everyone who is staking.\n    uint256 public constant REWARD_RATE = 100;\n    uint256 public s_lastUpdateTime;\n    uint256 public s_rewardPerTokenStored;\n\n    mapping(address => uint256) public s_userRewardPerTokenPaid;\n    mapping(address => uint256) public s_rewards;\n\n    uint256 private s_totalSupply;\n    mapping(address => uint256) public s_balances;\n\n    event Staked(address indexed user, uint256 indexed amount);\n    event WithdrewStake(address indexed user, uint256 indexed amount);\n    event RewardsClaimed(address indexed user, uint256 indexed amount);\n\n    constructor(address stakingToken, address rewardsToken) {\n        s_stakingToken = IERC20(stakingToken);\n        s_rewardsToken = IERC20(rewardsToken);\n    }\n\n    /**\n     * @notice How much reward a token gets based on how long it's been in and during which \"snapshots\"\n     */\n    function rewardPerToken() public view returns (uint256) {\n        if (s_totalSupply == 0) {\n            return s_rewardPerTokenStored;\n        }\n        return\n            s_rewardPerTokenStored +\n            (((block.timestamp - s_lastUpdateTime) * REWARD_RATE * 1e18) / s_totalSupply);\n    }\n\n    /**\n     * @notice How much reward a user has earned\n     */\n    function earned(address account) public view returns (uint256) {\n        return\n            ((s_balances[account] * (rewardPerToken() - s_userRewardPerTokenPaid[account])) /\n                1e18) + s_rewards[account];\n    }\n\n    /**\n     * @notice Deposit tokens into this contract\n     * @param amount | How much to stake\n     */\n    function stake(uint256 amount)\n        external\n        updateReward(msg.sender)\n        nonReentrant\n        moreThanZero(amount)\n    {\n        s_totalSupply += amount;\n        s_balances[msg.sender] += amount;\n        emit Staked(msg.sender, amount);\n        bool success = s_stakingToken.transferFrom(msg.sender, address(this), amount);\n        if (!success) {\n            revert TransferFailed();\n        }\n    }\n\n    /**\n     * @notice Withdraw tokens from this contract\n     * @param amount | How much to withdraw\n     */\n    function withdraw(uint256 amount) external updateReward(msg.sender) nonReentrant {\n        s_totalSupply -= amount;\n        s_balances[msg.sender] -= amount;\n        emit WithdrewStake(msg.sender, amount);\n        bool success = s_stakingToken.transfer(msg.sender, amount);\n        if (!success) {\n            revert TransferFailed();\n        }\n    }\n\n    /**\n     * @notice User claims their tokens\n     */\n    function claimReward() external updateReward(msg.sender) nonReentrant {\n        uint256 reward = s_rewards[msg.sender];\n        s_rewards[msg.sender] = 0;\n        emit RewardsClaimed(msg.sender, reward);\n        bool success = s_rewardsToken.transfer(msg.sender, reward);\n        if (!success) {\n            revert TransferFailed();\n        }\n    }\n\n    /********************/\n    /* Modifiers Functions */\n    /********************/\n    modifier updateReward(address account) {\n        s_rewardPerTokenStored = rewardPerToken();\n        s_lastUpdateTime = block.timestamp;\n        s_rewards[account] = earned(account);\n        s_userRewardPerTokenPaid[account] = s_rewardPerTokenStored;\n        _;\n    }\n\n    modifier moreThanZero(uint256 amount) {\n        if (amount == 0) {\n            revert NeedsMoreThanZero();\n        }\n        _;\n    }\n\n    /********************/\n    /* Getter Functions */\n    /********************/\n    // Ideally, we'd have getter functions for all our s_ variables we want exposed, and set them all to private.\n    // But, for the purpose of this demo, we've left them public for simplicity.\n\n    function getStaked(address account) public view returns (uint256) {\n        return s_balances[account];\n    }\n}\n"
    },
    "contracts/Options.sol": {
      "content": "// @notice This contract is in progress!!\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Covered European-Style Options\n/// @notice The purpose of this is to be a basic option market implementation. It ignores a lot of option specifis (like the Greeks, for example).\n/// This Smart Contract allows for the buying/writing of Covered Calls & Cash-Secured Puts with ETH as the underlying.\n/// Calls: Let you buy an asset(underlying) at a set price(the strike) on or after a specific date(expiration).\n/// Puts: Let you sell an asset(underlying) at a set price(the strike) on or after a specific date (expiration).\n/// Covered Call: The seller(writer) transfers ETH for collateral(the underlying) and writes a Covered Call. The buyer pays premium w DAI.\n/// Covered Call: At expiration, the buyer has the right to ETH at strike price if spot(market) price is greater than strike price. Settles with DAI.\n/// Cash-Secured Put: The writer transfers ETH for collateral. Buyer pays premium w DAI.\n/// Cash-Secured Put: At expiration, if market price less than strike, buyer has right to sell ETH at the strike to the writer. Settles w DAI.\n/// All options have the following properties:\n/// Strike price - The price at which the underlying asset can either be bought or sold. In this contract the strike == the initial spot price for simplicity.\n/// Expiry - The date at which the option expires.\n/// Premium - The price of the options contract that buyer pays.\n/// This smart contract supports two strategies for the option writer:\n/// 1. Covered Calls - You sell upside on ETH while you hold it for yield, which comes from premium (Netural/Bullish on ETH).\n/// 2. Cash-secured Puts - You earn yield on ETH (Bullish).\n\ncontract Options is ReentrancyGuard, Ownable {\n\n    ///STORAGE///\n\n    AggregatorV3Interface internal daiEthPriceFeed;\n\n    IERC20 dai;\n\n    uint256 public s_optionCounter;\n\n    uint256 public s_optionId;\n\n    mapping(address => address) public s_tokenToEthFeed;\n    mapping(uint256 => Option) public s_optionIdToOption;\n    mapping(address => uint256[]) public s_tradersPosition;\n\n    enum OptionState {\n        Open,\n        Bought,\n        Cancelled,\n        Exercised\n    }\n\n    enum OptionType {\n        Call,\n        Put\n    }\n\n    struct Option {\n        address writer;\n        address buyer;\n        uint256 amount;\n        uint256 strike;\n        uint256 premiumDue;\n        uint256 expiration;\n        uint256 collateral;\n        OptionState optionState;\n        OptionType optionType;\n    }\n\n    ///ERRORS///\n\n    error TransferFailed();\n    error NeedsMoreThanZero();\n    error OptionNotValid(uint256 _optionId);\n\n    ///EVENTS///\n\n    event CallOptionOpen(uint256 id, address writer, uint256 amount, uint256 strike, uint256 premium, uint256 expiration, uint256 value);\n    event PutOptionOpen(uint256 id, address writer, uint256 amount, uint256 strike, uint256 premium, uint256 expiration, uint256 value);\n    event CallOptionBought(address buyer, uint256 id);\n    event PutOptionBought(address buyer, uint256 id);\n    event CallOptionExercised(address buyer, uint256 id);\n    event PutOptionExercised(address buyer, uint256 id);\n    event OptionExpiresWorthless(address buyer, uint256 Id);\n    event FundsRetrieved(address writer, uint256 id, uint256 value);\n    //event AllowedTokenSet(address token, uint256 price);\n\n    ///@dev CHAINLINK PRICEFEEDS & DAI ADDRESSES\n    ///NETWORK: KOVAN\n    ///DAI/ETH Address: 0x22B58f1EbEDfCA50feF632bD73368b2FdA96D541\n    ///Kovan DAI Addr: 0x4f96fe3b7a6cf9725f59d353f723c1bdb64ca6aa\n    ///NETWORK: RINKEBY\n    ///DAI/ETH Address: 0x74825DbC8BF76CC4e9494d0ecB210f676Efa001D\n    ///Rinkeby DAI Addr: 0x4f96fe3b7a6cf9725f59d353f723c1bdb64ca6aa (faucet token)\n    constructor(address _priceFeed, address _daiAddr) {\n        daiEthPriceFeed = AggregatorV3Interface(_priceFeed);\n        dai = IERC20(_daiAddr);\n    }\n\n    ///@dev A seller writes a call option. ETH is sent to contract for collateral.\n    ///@param _amount is the number of options to be written.\n    ///@param _strike is the price of ETH in DAI. Here, strike == current spot price,(for a Dapp, this'd probably be best deteremined on frontend)\n    ///@param _premiumDue the cost of the option call paid by buyer in dai. (For dapp, prob determined on frontend and NOT by the WRITER)\n    ///@param _daysToExpiry days until option expires and can then be exercised or cancelled.\n    ///@param _daiAmount is the amount of dai\n    function writeCallOption(\n        uint256 _amount,\n        uint256 _strike,\n        uint256 _premiumDue,\n        uint256 _daysToExpiry,\n        uint256 _daiAmount\n    ) external payable moreThanZero(_amount, _strike, _premiumDue) {\n\n        //returns x amt of ether for 1 dai...1DAI/xETH\n        uint256 marketPriceEthPerOneDai = _amount * getPriceFeed(_daiAmount);\n        //returns x amt of dai per 1 eth...1ETH/xDAI\n        uint256 marketPriceDaiPerOneEth = _daiAmount /  marketPriceEthPerOneDai;\n\n        //eth sent to contract for collateral MUST equal current spot price (1DAI/xETH)\n        require(msg.value == marketPriceEthPerOneDai, \"CALL: ETH VALUE MUST EQUAL SPOT PRICE\");\n        //So, In this contract the strike == the spot price for simplicity.\n        require(marketPriceDaiPerOneEth == _strike, \"CALL: WRONG ETH COLLATERAL\");\n        \n        s_optionIdToOption[s_optionCounter] = Option(\n            payable(msg.sender),\n            address(0),\n            _amount,\n            _strike,\n            _premiumDue,\n            block.timestamp + _daysToExpiry,\n            msg.value,\n            OptionState.Open,\n            OptionType.Call\n        );\n\n        s_tradersPosition[msg.sender].push(s_optionCounter);\n        s_optionId = s_optionCounter++;\n\n        emit CallOptionOpen(s_optionId, msg.sender, _amount, _strike, _premiumDue, block.timestamp + _daysToExpiry, msg.value);\n    }\n\n    ///@dev Buy an open call option.\n    ///@param _optionId would need to be used to access the correct option. Every buyer must have a seller.\n    function buyCallOption(uint256 _optionId)\n        external\n        optionExists(_optionId)\n        isValidOpenOption(_optionId)\n        nonReentrant\n    {\n        Option memory option = s_optionIdToOption[_optionId];\n\n        require(option.optionType == OptionType.Call, \"NOT A CALL\");\n\n        //buyer pays w dai\n        bool paid = dai.transferFrom(msg.sender, address(this), option.premiumDue);\n        if (!paid) revert TransferFailed();\n\n        //dai transfered to writer\n        paid = dai.transfer(option.writer, option.premiumDue);\n        if (!paid) revert TransferFailed();\n\n        s_optionIdToOption[_optionId].buyer = msg.sender;\n        s_optionIdToOption[_optionId].optionState = OptionState.Bought;\n        s_tradersPosition[msg.sender].push(_optionId);\n\n        emit CallOptionBought(msg.sender, _optionId);\n    }\n\n    ///@dev A seller writes a put option. ETH is sent to contract for collateral.\n    ///@param _amount is the number of options to be written.\n    ///@param _strike is the price of ETH in DAI. Here, strike == current spot price.\n    ///@param _premiumDue the cost of the option call paid by buyer (in DAI).\n    ///@param _daysToExpiry days until option expires and can then be exercised or cancelled.\n    ///@param _daiAmount is the amount of dai\n    function writePutOption(\n        uint256 _amount,\n        uint256 _strike,\n        uint256 _premiumDue,\n        uint256 _daysToExpiry,\n        uint256 _daiAmount\n    ) external payable moreThanZero(_amount, _strike, _premiumDue) {\n\n        //returns x amt of ether for 1 dai...1DAI/ETH\n        uint256 marketPriceEthPerOneDai = _amount * getPriceFeed(_daiAmount);\n        //returns x amt of dai per 1 eth...1ETH/DAI\n        uint256 marketPriceDaiPerOneEth = _daiAmount /  marketPriceEthPerOneDai;\n\n        //Eth sent to contract for collateral MUST equal the value of ETH vs DAI.\n        require(msg.value == marketPriceEthPerOneDai, \"PUT: ETH VALUE MUST EQUAL DAI\");\n        //So, In this contract the strike == the spot price for simplicity.\n        require(marketPriceDaiPerOneEth == _strike, \"PUT: WRONG ETH COLLATERAL\");\n\n        s_optionIdToOption[s_optionCounter] = Option(\n            payable(msg.sender),\n            address(0),\n            _amount,\n            _strike,\n            _premiumDue,\n            block.timestamp + _daysToExpiry,\n            msg.value,\n            OptionState.Open,\n            OptionType.Put\n        );\n\n        s_tradersPosition[msg.sender].push(s_optionCounter);\n        s_optionId = s_optionCounter++;\n\n        emit PutOptionOpen(s_optionId, msg.sender, _amount, _strike, _premiumDue, block.timestamp + _daysToExpiry, msg.value);\n    }\n\n    ///@dev Buy an open put option.\n    ///@param _optionId Would need to be used to access the correct option. Every buyer must have a seller.\n    function buyPutOption(uint256 _optionId)\n        external\n        optionExists(_optionId)\n        isValidOpenOption(_optionId)\n        nonReentrant\n    {\n        Option memory option = s_optionIdToOption[_optionId];\n\n        require(option.optionType == OptionType.Put, \"NOT A PUT\");\n\n        //pay premium w dai\n        bool paid = dai.transferFrom(msg.sender, address(this), option.premiumDue);\n        if (!paid) revert TransferFailed();\n\n        //transfer premium to writer\n        paid = dai.transfer(option.writer, option.premiumDue);\n        if (!paid) revert TransferFailed();\n\n        s_optionIdToOption[_optionId].buyer = msg.sender;\n        s_optionIdToOption[_optionId].optionState = OptionState.Bought;\n        s_tradersPosition[msg.sender].push(_optionId);\n\n        emit PutOptionBought(msg.sender, _optionId);\n    }\n\n    ///@dev The buyer can exercise a call option at expiration.\n    ///@param _optionId would need to be used to access the correct option. Every buyer must have a seller.\n    ///@param _daiAmount is the amount of dai\n    function exerciseCallOption(uint256 _optionId, uint256 _daiAmount)\n        external\n        payable\n        optionExists(_optionId)\n        nonReentrant\n    {\n        Option memory option = s_optionIdToOption[_optionId];\n\n        require(msg.sender == option.buyer, \"NOT BUYER\");\n        require(option.optionState == OptionState.Bought, \"NEVER BOUGHT\");\n        require(option.expiration < block.timestamp, \"HAS NOT EXPIRED\");\n\n        //returns # of dai for 1 ETH. Ex: 1 dai = ~0.0002eth in real life right now\n        uint256 marketPriceEthPerOneDai = option.amount * getPriceFeed(_daiAmount);\n        \n        //returns 1 eth = x amt of dai...\n        uint256 marketPriceDaiPerOneEth = _daiAmount /  marketPriceEthPerOneDai;\n\n        //If spot < strike, option is worthless\n        require(marketPriceDaiPerOneEth > option.strike, \"NOT GREATER THAN STRIKE\");\n\n        //buyer gets right to buy ETH at strike w DAI\n        bool paid = dai.transferFrom(msg.sender, address(this), option.strike);\n        if (!paid) revert TransferFailed();\n\n        //transfer to msg.sender the writer's ETH collateral\n        require(address(this).balance >= option.collateral, \"NOT ENOUGH ETH BALANCE\");\n        (paid, ) = payable(msg.sender).call{value: option.collateral}(\"\");\n        if(!paid) revert TransferFailed();\n\n        //transfer dai to option writer\n        paid = dai.transfer(option.writer, option.strike);\n        if (!paid) revert TransferFailed();\n     \n        s_optionIdToOption[_optionId].optionState = OptionState.Exercised;\n\n        emit CallOptionExercised(msg.sender, _optionId);\n    }\n\n    ///@dev The buyer can exercise a put option at expiration.\n    ///@param _optionId would need to be used to access the correct option. Every buyer must have a seller.\n    ///@param _daiAmount is the amount of dai\n    function exercisePutOption(uint256 _optionId, uint256 _daiAmount)\n        external\n        payable\n        optionExists(_optionId)\n        nonReentrant\n    {\n        Option memory option = s_optionIdToOption[_optionId];\n\n        require(msg.sender == option.buyer, \"NOT BUYER\");\n        require(option.optionState == OptionState.Bought, \"NEVER BOUGHT\");\n        require(option.expiration < block.timestamp, \"HAS NOT EXPIRED\");\n\n        //returns # of dai for 1 ETH. Ex: 1 dai = ~0.0002eth in real life right now\n        uint256 marketPriceEthPerOneDai = option.amount * getPriceFeed(_daiAmount);\n\n        //returns 1 eth = x amt of dai...\n        uint256 marketPriceDaiPerOneEth = _daiAmount /  marketPriceEthPerOneDai;\n        \n        //if spot > strike, option is worthless\n        require(marketPriceDaiPerOneEth < option.strike, \"MUST BE LESS THAN STRIKE\");\n\n        //buyer gets to sell ETH(gets collateral) for DAI at strike to option writer\n        bool paid = dai.transferFrom(msg.sender, address(this), option.strike);\n        if (!paid) revert TransferFailed();\n\n        (paid,) = payable(msg.sender).call{value: option.collateral}(\"\");\n        if(!paid) revert TransferFailed();\n\n        //transfer dai to option writer\n        paid = dai.transfer(option.writer, option.strike);\n        if (!paid) revert TransferFailed();\n     \n        s_optionIdToOption[_optionId].optionState = OptionState.Exercised;\n\n        emit PutOptionExercised(msg.sender, _optionId);\n    }\n\n    ///@dev The writer can cancel options that have expired and are worthless\n    ///@param _optionId would need to be used to access the correct option. Every buyer must have a seller.\n    ///@param _daiAmount is the amount of dai\n    function optionExpiresWorthless(uint256 _optionId, uint256 _daiAmount) external optionExists(_optionId) {\n\n        Option memory option = s_optionIdToOption[_optionId];\n\n        require(s_optionIdToOption[_optionId].writer == msg.sender, \"NOT WRITER\");\n        require(option.optionState == OptionState.Bought, \"NEVER BOUGHT\");\n        require(option.expiration <= block.timestamp, \"NOT EXPIRED\");\n\n        uint256 marketPriceEthPerOneDai = option.amount * getPriceFeed(_daiAmount);\n\n        uint256 marketPriceDaiPerOneEth = _daiAmount /  marketPriceEthPerOneDai;\n\n        if (option.optionType == OptionType.Call) {\n\n            //For call, if spot < strike, call options expire worthless\n            require(marketPriceDaiPerOneEth < option.strike, \"PRICE NOT LESS THAN STRIKE\");\n            s_optionIdToOption[_optionId].optionState = OptionState.Cancelled;\n\n        } else {\n\n            //For put, if spot > strike, put options expire worthless\n            require(marketPriceDaiPerOneEth > option.strike, \"PRICE NOT GREATER THAN STRIKE\");\n            s_optionIdToOption[_optionId].optionState = OptionState.Cancelled;\n        }\n\n        emit OptionExpiresWorthless(msg.sender, _optionId);\n    }\n\n    ///@dev If options are worthless(cancelled), then writer can get back ETH collateral\n    ///@param _optionId would need to be used to access the correct option. Every buyer must have a seller.\n    function retrieveExpiredFunds(uint256 _optionId) external nonReentrant {\n        Option memory option = s_optionIdToOption[_optionId];\n        \n        require(option.optionState == OptionState.Cancelled, \"NOT CANCELED\");\n        require(option.expiration < block.timestamp, \"NOT EXPIRED\");\n        require(msg.sender == option.writer, \"NOT WRITER\");\n\n        //check contract balance is enough for transfer\n        require(address(this).balance >= option.collateral, \"NOT ENOUGH ETH\");\n\n        //return ETH collateral to writer if options expired worthless(cancelled)\n        (bool paid,) = payable(msg.sender).call{value: option.collateral}(\"\");\n        if(!paid) revert TransferFailed();\n\n        emit FundsRetrieved(msg.sender, _optionId, option.collateral);\n    }\n\n    /*********************************/\n    /* Oracle (Chainlink) Functions */\n    /*********************************/\n\n    ///@dev get the DaiEthPriceFeed (18 decimals) from Chainlink (look at consrtuctor for contract addresses)\n    ///@param _amountInDai the amount of Dai\n    function getPriceFeed(uint256 _amountInDai) public view returns (uint256) {\n        (, int256 price, , , ) = daiEthPriceFeed.latestRoundData();\n        return (uint256(price) * _amountInDai) / 1e18;\n    }\n\n    /**************/\n    /* Modifiers */\n    /*************/\n\n    modifier moreThanZero(\n        uint256 amount,\n        uint256 strikePrice,\n        uint256 premiumCost\n    ) {\n        if (amount <= 0 || strikePrice <= 0 || premiumCost <= 0) revert NeedsMoreThanZero();\n        _;\n    }\n\n    modifier optionExists(uint256 optionId) {\n        if (s_optionIdToOption[optionId].writer == address(0)) revert OptionNotValid(optionId);\n        _;\n    }\n\n    modifier isValidOpenOption(uint256 optionId) {\n        if (\n            s_optionIdToOption[optionId].optionState != OptionState.Open ||\n            s_optionIdToOption[optionId].expiration > block.timestamp\n            // || s_optionIdToOption[optionId].buyer == address(0)\n        ) revert OptionNotValid(optionId);\n        _;\n    }\n}\n"
    },
    "contracts/Lending.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// This contract is not audited!!!\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// import \"hardhat/console.sol\";\n\nerror TransferFailed();\nerror TokenNotAllowed(address token);\nerror NeedsMoreThanZero();\n\ncontract Lending is ReentrancyGuard, Ownable {\n    mapping(address => address) public s_tokenToPriceFeed;\n    address[] public s_allowedTokens;\n    // Account -> Token -> Amount\n    mapping(address => mapping(address => uint256)) public s_accountToTokenDeposits;\n    // Account -> Token -> Amount\n    mapping(address => mapping(address => uint256)) public s_accountToTokenBorrows;\n\n    // 5% Liquidation Reward\n    uint256 public constant LIQUIDATION_REWARD = 5;\n    // At 80% Loan to Value Ratio, the loan can be liquidated\n    uint256 public constant LIQUIDATION_THRESHOLD = 80;\n    uint256 public constant MIN_HEALH_FACTOR = 1e18;\n\n    event AllowedTokenSet(address indexed token, address indexed priceFeed);\n    event Deposit(address indexed account, address indexed token, uint256 indexed amount);\n    event Borrow(address indexed account, address indexed token, uint256 indexed amount);\n    event Withdraw(address indexed account, address indexed token, uint256 indexed amount);\n    event Repay(address indexed account, address indexed token, uint256 indexed amount);\n    event Liquidate(\n        address indexed account,\n        address indexed repayToken,\n        address indexed rewardToken,\n        uint256 halfDebtInEth,\n        address liquidator\n    );\n\n    function deposit(address token, uint256 amount)\n        external\n        nonReentrant\n        isAllowedToken(token)\n        moreThanZero(amount)\n    {\n        emit Deposit(msg.sender, token, amount);\n        s_accountToTokenDeposits[msg.sender][token] += amount;\n        bool success = IERC20(token).transferFrom(msg.sender, address(this), amount);\n        if (!success) revert TransferFailed();\n    }\n\n    function withdraw(address token, uint256 amount) external nonReentrant moreThanZero(amount) {\n        require(s_accountToTokenDeposits[msg.sender][token] >= amount, \"Not enough funds\");\n        emit Withdraw(msg.sender, token, amount);\n        _pullFunds(msg.sender, token, amount);\n        require(healthFactor(msg.sender) >= MIN_HEALH_FACTOR, \"Platform will go insolvent!\");\n    }\n\n    function _pullFunds(\n        address account,\n        address token,\n        uint256 amount\n    ) private {\n        require(s_accountToTokenDeposits[account][token] >= amount, \"Not enough funds to withdraw\");\n        s_accountToTokenDeposits[account][token] -= amount;\n        bool success = IERC20(token).transfer(msg.sender, amount);\n        if (!success) revert TransferFailed();\n    }\n\n    function borrow(address token, uint256 amount)\n        external\n        nonReentrant\n        isAllowedToken(token)\n        moreThanZero(amount)\n    {\n        require(IERC20(token).balanceOf(address(this)) >= amount, \"Not enough tokens to borrow\");\n        s_accountToTokenBorrows[msg.sender][token] += amount;\n        emit Borrow(msg.sender, token, amount);\n        bool success = IERC20(token).transfer(msg.sender, amount);\n        if (!success) revert TransferFailed();\n        require(healthFactor(msg.sender) >= MIN_HEALH_FACTOR, \"Platform will go insolvent!\");\n    }\n\n    function liquidate(\n        address account,\n        address repayToken,\n        address rewardToken\n    ) external nonReentrant {\n        require(healthFactor(account) < MIN_HEALH_FACTOR, \"Account can't be liquidated!\");\n        uint256 halfDebt = s_accountToTokenBorrows[account][repayToken] / 2;\n        uint256 halfDebtInEth = getEthValue(repayToken, halfDebt);\n        require(halfDebtInEth > 0, \"Choose a different repayToken!\");\n        uint256 rewardAmountInEth = (halfDebtInEth * LIQUIDATION_REWARD) / 100;\n        uint256 totalRewardAmountInRewardToken = getTokenValueFromEth(\n            rewardToken,\n            rewardAmountInEth + halfDebtInEth\n        );\n        emit Liquidate(account, repayToken, rewardToken, halfDebtInEth, msg.sender);\n        _repay(account, repayToken, halfDebt);\n        _pullFunds(account, rewardToken, totalRewardAmountInRewardToken);\n    }\n\n    function repay(address token, uint256 amount)\n        external\n        nonReentrant\n        isAllowedToken(token)\n        moreThanZero(amount)\n    {\n        emit Repay(msg.sender, token, amount);\n        _repay(msg.sender, token, amount);\n    }\n\n    function _repay(\n        address account,\n        address token,\n        uint256 amount\n    ) private {\n        // require(s_accountToTokenBorrows[account][token] - amount >= 0, \"Repayed too much!\");\n        // On 0.8+ of solidity, it auto reverts math that would drop below 0 for a uint256\n        s_accountToTokenBorrows[account][token] -= amount;\n        bool success = IERC20(token).transferFrom(msg.sender, address(this), amount);\n        if (!success) revert TransferFailed();\n    }\n\n    function getAccountInformation(address user)\n        public\n        view\n        returns (uint256 borrowedValueInETH, uint256 collateralValueInETH)\n    {\n        borrowedValueInETH = getAccountBorrowedValue(user);\n        collateralValueInETH = getAccountCollateralValue(user);\n    }\n\n    function getAccountCollateralValue(address user) public view returns (uint256) {\n        uint256 totalCollateralValueInETH = 0;\n        for (uint256 index = 0; index < s_allowedTokens.length; index++) {\n            address token = s_allowedTokens[index];\n            uint256 amount = s_accountToTokenDeposits[user][token];\n            uint256 valueInEth = getEthValue(token, amount);\n            totalCollateralValueInETH += valueInEth;\n        }\n        return totalCollateralValueInETH;\n    }\n\n    function getAccountBorrowedValue(address user) public view returns (uint256) {\n        uint256 totalBorrowsValueInETH = 0;\n        for (uint256 index = 0; index < s_allowedTokens.length; index++) {\n            address token = s_allowedTokens[index];\n            uint256 amount = s_accountToTokenBorrows[user][token];\n            uint256 valueInEth = getEthValue(token, amount);\n            totalBorrowsValueInETH += valueInEth;\n        }\n        return totalBorrowsValueInETH;\n    }\n\n    function getEthValue(address token, uint256 amount) public view returns (uint256) {\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(s_tokenToPriceFeed[token]);\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        // 2000 DAI = 1 ETH\n        // 0.002 ETH per DAI\n        // price will be something like 20000000000000000\n        // So we multiply the price by the amount, and then divide by 1e18\n        // 2000 DAI * (0.002 ETH / 1 DAI) = 0.002 ETH\n        // (2000 * 10 ** 18) * ((0.002 * 10 ** 18) / 10 ** 18) = 0.002 ETH\n        return (uint256(price) * amount) / 1e18;\n    }\n\n    function getTokenValueFromEth(address token, uint256 amount) public view returns (uint256) {\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(s_tokenToPriceFeed[token]);\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        return (amount * 1e18) / uint256(price);\n    }\n\n    function healthFactor(address account) public view returns (uint256) {\n        (uint256 borrowedValueInEth, uint256 collateralValueInEth) = getAccountInformation(account);\n        uint256 collateralAdjustedForThreshold = (collateralValueInEth * LIQUIDATION_THRESHOLD) /\n            100;\n        if (borrowedValueInEth == 0) return 100e18;\n        return (collateralAdjustedForThreshold * 1e18) / borrowedValueInEth;\n    }\n\n    /********************/\n    /* Modifiers */\n    /********************/\n\n    modifier isAllowedToken(address token) {\n        if (s_tokenToPriceFeed[token] == address(0)) revert TokenNotAllowed(token);\n        _;\n    }\n\n    modifier moreThanZero(uint256 amount) {\n        if (amount == 0) {\n            revert NeedsMoreThanZero();\n        }\n        _;\n    }\n\n    /********************/\n    /* DAO / OnlyOwner Functions */\n    /********************/\n    function setAllowedToken(address token, address priceFeed) external onlyOwner {\n        bool foundToken = false;\n        uint256 allowedTokensLength = s_allowedTokens.length;\n        for (uint256 index = 0; index < allowedTokensLength; index++) {\n            if (s_allowedTokens[index] == token) {\n                foundToken = true;\n                break;\n            }\n        }\n        if (!foundToken) {\n            s_allowedTokens.push(token);\n        }\n        s_tokenToPriceFeed[token] = priceFeed;\n        emit AllowedTokenSet(token, priceFeed);\n    }\n\n    /********************/\n    /* Getter Functions */\n    /********************/\n    // Ideally, we'd have getter functions for all our s_ variables we want exposed, and set them all to private.\n    // But, for the purpose of this demo, we've left them public for simplicity.\n}\n"
    },
    "contracts/stablecoins/CentralizedStableCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Based off:\n// https://github.com/centrehq/centre-tokens/blob/master/contracts/v2/FiatTokenV2.sol\n// https://github.com/centrehq/centre-tokens/blob/master/contracts/v1/FiatTokenV1.sol\n// aka USDC\n\n// This is considered an exogenous, centralized, anchored (pegged), fiat collateralized, low volitility coin\n\n// Collateral: Exogenous\n// Minting: Centralized\n// Value: Anchored (Pegged to USD)\n// Collateral Type: Fiat\n\n// Also sometimes just refered to as \"Fiat Collateralized Stablecoin\"\n// But maybe a better name would be \"FiatCoin\"\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nerror CentralizedStableCoin__NotMinter();\nerror CentralizedStableCoin__AddressBlacklisted();\nerror CentralizedStableCoin__NotZeroAddress();\nerror CentralizedStableCoin__AmountMustBeMoreThanZero();\nerror CentralizedStableCoin__ExceededMinterAllowance();\nerror CentralizedStableCoin__BurnAmountExceedsBalance();\n\ncontract CentralizedStableCoin is ERC20Burnable, Ownable {\n    mapping(address => bool) internal s_blacklisted;\n    mapping(address => bool) internal s_minters;\n    mapping(address => uint256) internal s_minterAllowed;\n\n    // Events\n    event MinterConfigured(address indexed minter, uint256 minterAllowedAmount);\n    event MinterRemoved(address indexed oldMinter);\n    event Blacklisted(address indexed _account);\n    event UnBlacklisted(address indexed _account);\n\n    // Modifiers\n    modifier onlyMinters() {\n        if (!s_minters[msg.sender]) {\n            revert CentralizedStableCoin__NotMinter();\n        }\n        _;\n    }\n\n    modifier notBlacklisted(address addressToCheck) {\n        if (s_blacklisted[addressToCheck]) {\n            revert CentralizedStableCoin__AddressBlacklisted();\n        }\n        _;\n    }\n\n    constructor(uint256 initialSupply) ERC20(\"CentralizedStablecoin\", \"CSC\") {\n        _mint(msg.sender, initialSupply);\n    }\n\n    function mint(address _to, uint256 _amount)\n        external\n        onlyMinters\n        notBlacklisted(msg.sender)\n        notBlacklisted(_to)\n        returns (bool)\n    {\n        if (_to == address(0)) {\n            revert CentralizedStableCoin__NotZeroAddress();\n        }\n        if (_amount <= 0) {\n            revert CentralizedStableCoin__AmountMustBeMoreThanZero();\n        }\n\n        uint256 mintingAllowedAmount = s_minterAllowed[msg.sender];\n        if (_amount > mintingAllowedAmount) {\n            revert CentralizedStableCoin__ExceededMinterAllowance();\n        }\n        s_minterAllowed[msg.sender] = mintingAllowedAmount - _amount;\n        _mint(msg.sender, mintingAllowedAmount);\n        return true;\n    }\n\n    function burn(uint256 _amount) public override onlyMinters notBlacklisted(msg.sender) {\n        uint256 balance = balanceOf(msg.sender);\n        if (_amount <= 0) {\n            revert CentralizedStableCoin__AmountMustBeMoreThanZero();\n        }\n        if (balance < _amount) {\n            revert CentralizedStableCoin__BurnAmountExceedsBalance();\n        }\n        _burn(msg.sender, _amount);\n    }\n\n    /***************************/\n    /* Minter settings */\n    /***************************/\n\n    function configureMinter(address minter, uint256 minterAllowedAmount)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        s_minters[minter] = true;\n        s_minterAllowed[minter] = minterAllowedAmount;\n        emit MinterConfigured(minter, minterAllowedAmount);\n        return true;\n    }\n\n    function removeMinter(address minter) external onlyOwner returns (bool) {\n        s_minters[minter] = false;\n        s_minterAllowed[minter] = 0;\n        emit MinterRemoved(minter);\n        return true;\n    }\n\n    /***************************/\n    /* Blacklisting Functions */\n    /***************************/\n\n    function isBlacklisted(address _account) external view returns (bool) {\n        return s_blacklisted[_account];\n    }\n\n    function blacklist(address _account) external onlyOwner {\n        s_blacklisted[_account] = true;\n        emit Blacklisted(_account);\n    }\n\n    function unBlacklist(address _account) external onlyOwner {\n        s_blacklisted[_account] = false;\n        emit UnBlacklisted(_account);\n    }\n\n    /***************************/\n    /* Blacklisting overrides */\n    /***************************/\n\n    function approve(address spender, uint256 value)\n        public\n        override\n        notBlacklisted(msg.sender)\n        notBlacklisted(spender)\n        returns (bool)\n    {\n        super.approve(spender, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        public\n        override\n        notBlacklisted(msg.sender)\n        notBlacklisted(from)\n        notBlacklisted(to)\n        returns (bool)\n    {\n        super.transferFrom(from, to, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value)\n        public\n        override\n        notBlacklisted(msg.sender)\n        notBlacklisted(to)\n        returns (bool)\n    {\n        super.transfer(msg.sender, value);\n        return true;\n    }\n}\n"
    },
    "contracts/stablecoins/endogenousAnchoredCoin/AlgorithmicStableCoin.sol": {
      "content": "// https://blog.bitmex.com/wp-content/uploads/2018/06/A-Note-on-Cryptocurrency-Stabilisation-Seigniorage-Shares.pdf\n\n// This would be similar to a UST/LUNA\n\n// This is considered an Endogenous, Decentralized, Reflexive, Crypto Collateralized low volitility coin\n\n// Collateral: Endogenous\n// Minting: Decentralized\n// Value: Reflexive\n// Collateral Type: Crypto\n\n// Sometimes just refered to as \"Algorithmic Stablecoin\"\n\n// But maybe a better name would be EndoDrCCoin (EndoDocCoin?), or maybe like \"RobertsCoin\" or something after the Sam Roberts paper...\n// We should fix the name as a community\n\npragma solidity ^0.8.7;\n\ncontract AlgorithmicStableCoin {\n\n}\n\n// To be created...\n"
    },
    "contracts/stablecoins/endogenousIndexCoin/Fpi.sol": {
      "content": "// This would be similar to a FPI/FPIX\n\n// To be created..."
    },
    "contracts/stablecoins/exogenousIndexCoin/ICEngine.sol": {
      "content": "// TODO...."
    },
    "contracts/Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Inspired by https://solidity-by-example.org/defi/uniswap-v2/\n\npragma solidity ^0.8.7;\n\n// This is not a full swapping contract, but an implementation of how to interact with uniswap or a uniswap clone\ncontract TestUniswap {\n    address private constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    function swap(\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _to\n    ) external {\n        IERC20(_tokenIn).transferFrom(msg.sender, address(this), _amountIn);\n        IERC20(_tokenIn).approve(UNISWAP_V2_ROUTER, _amountIn);\n\n        address[] memory path;\n        if (_tokenIn == WETH || _tokenOut == WETH) {\n            path = new address[](2);\n            path[0] = _tokenIn;\n            path[1] = _tokenOut;\n        } else {\n            path = new address[](3);\n            path[0] = _tokenIn;\n            path[1] = WETH;\n            path[2] = _tokenOut;\n        }\n\n        IUniswapV2Router(UNISWAP_V2_ROUTER).swapExactTokensForTokens(\n            _amountIn,\n            _amountOutMin,\n            path,\n            _to,\n            block.timestamp\n        );\n    }\n}\n\ninterface IUniswapV2Router {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n\n// License\n// MIT License\n\n// Copyright (c) 2018 Tasuku Nakamura\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}